classdef Act < handle
    
    methods
        %% Metodo che genera velocita lineare e angolare per il robot
        function [vr,wr] = commands(~,rx,ry,rtheta,tspan,robot)
            grid = robot.grid; directive = robot.plan.directive;
            gradX = directive.gradX; gradY = directive.gradY;
            i = grid.coord2index([rx,ry]);
            thetaN = atan2(gradY(i(1),i(2)),gradX(i(1),i(2)));
            thetaDiff = atan2(sin(thetaN-rtheta),cos(thetaN-rtheta));
            vgrad = [gradX(i(1),i(2)) gradY(i(1),i(2))];
            Mv = norm(vgrad);
            vr = (Mv * cos(thetaDiff));
            
            rx1 = rx + vgrad(1)*tspan;
            ry1 = ry + vgrad(2)*tspan;
            j = grid.coord2index([rx1,ry1]);
            thetaN1 = atan2(gradY(j(1),j(2)),gradX(j(1),j(2)));
            
            thetaDdiff = atan2(sin(thetaN1-thetaN),cos(thetaN1-thetaN));
            thetaDdot = thetaDdiff/tspan;
            Kc = 10; eps = 0.001; v = 1;
            Kw = (thetaDdot + Kc * abs(thetaDiff)^v * ...
                sign(thetaDiff))/(thetaDiff+eps);
            wr = (abs(thetaDiff) >= eps) * Kw * (thetaDiff);
        end
        
        %% Actuator interface
        function obj = move(obj,robot,tspan)
            rx = obj.xc;
            ry = obj.yc;
            rtheta = obj.theta;
            [vr,wr] = obj.act.commands(rx,ry,rtheta,tspan,obj);
            Xdot = robot.ode(vr,wr,rtheta,ob);
            
            rx2 = rx + tspan/2*Xdot(1);
            ry2 = ry + tspan/2*Xdot(2);
            rtheta2 = rtheta + tspan/2*Xdot(3);
            [vr,wr] = obj.act.commands(rx2,ry2,rtheta2,tspan,obj);
            Xdot = obj.act.ode(vr,wr,rtheta2,obj.R,obj.L);
            
            obj.xc = rx + tspan*Xdot(1);
            obj.yc = ry + tspan*Xdot(2);
            obj.theta = rtheta + tspan*Xdot(3);
        end
        
        
        function [Xdot,wRwL] = ode(~,vr,wr,theta,R,L)
            %K rende possibile esprimere vr e wr in funzione delle
            %due velocita impresse alle ruote
            K = [R/2 R/2 ; R/L -R/L];
            wRwL = K \ [vr ; wr];
            Xdot = ([cos(theta) 0 ; sin(theta) 0 ; 0 1] * K * wRwL);
        end
    end
end
