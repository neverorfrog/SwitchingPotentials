\documentclass[14pt,a4paper]{extarticle}
\usepackage[margin=3cm]{geometry}
\usepackage{graphicx}\graphicspath{{figure/}}\usepackage{float} 
\usepackage[backend=biber]{biblatex}
\usepackage{subcaption} \usepackage{caption}
\usepackage{mathtools} \usepackage{amsmath}
\usepackage{xcolor}\usepackage{tcolorbox}
\usepackage{listings}\usepackage{adjustbox}
\tcbuselibrary{listingsutf8,skins,fitting}

\newtcolorbox{nota}[0]{
	beforeafter skip balanced=5mm,
	fontupper=\small
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{lightgray}{rgb}{0.95,0.95,0.95}

\lstset{
    commentstyle=\color{codegreen},
    numberstyle=\tiny\color{codegray},
    keywordstyle=\color{codepurple},  
    numbers=left,
    language=Matlab,
    basicstyle=\small,
    backgroundcolor=\color{lightgray},
    tabsize=3
}


\addbibresource{bibliografia.bib}

\title{Path planning locale per robot mobili \\ basato su switching tra potenziali artificiali}
\author{}
\date{} 

\begin{document}

\maketitle \newpage %frontespizio
\tableofcontents \newpage %sommario

\begin{abstract}
In questo lavoro di tesi é stato sviluppato, basondosi principalmente sull'articolo \cite{dalfonso} del Professore D'Alfonso et al, un modulo software in Matlab che affronta un problema di path planning per robot mobili. L'obiettivo é di guidare un robot mobile all'interno di un ambiente non noto, cercando di fargli raggiungere un punto prestabilito, senza collisioni con eventuali ostacoli. Lo strumento principale utilizzato é quello dei potenziali artificiali, ma con un meccanismo di switching a stati. Ci si é concentrati anche a curare l'architettura del software, sfruttando la programmazione orientata agli oggetti messa a disposizione da Matlab, al fine di rendere il software modulare e riutilizzabile per eventuali espansioni future.
\end{abstract}

\section{Introduzione}
È innegabile che in questi anni si stia assistendo ad un aumento vertiginoso di sviluppo ed uso della robotica. È importante però evidenziare una distinzione tra due concetti apparentemente simili, ma per certi versi opposti, che caratterizzano due macro-categorie della robotica: automazione e autonomia. Il primo riguarda quei robot, tipicamente industriali, che operano in ambienti noti a priori ed eseguono in loop un compito predefinito; automatizzare, perciò, vuol dire sostituire l'essere umano in compiti ripetitivi e solitamente privi di eventi inaspettati. L'autonomia, invece, ben più complessa da realizzare, é caratteristica di quei sistemi che hanno un certo grado di inconsapevolezza sul proprio futuro e l'ambiente circostante.  Il robot, quindi, é definito autonomo se é un agente intelligente situato nello spazio fisico, dove un agente intelligente si definisce come un'entità che \textbf{osserva} l'ambiente e prende delle \textbf{azioni} per massimizzare il raggiungimento del suo \textbf{obiettivo}\cite{murphy}. Nel caso specifico di questa tesi, l'ambiente del robot autonomo é lo spazio bidimensionale (una superficie), e il suo obiettivo é un punto in questo spazio. Massimizzare il raggiungimento di questo punto vuol dire arrivarci nel minor tempo possibile, senza collidere con eventuali ostacoli. Quindi, il robot autonomo deve compiere una serie di azioni, non note a priori e definite da un algoritmo di pianificazione che si basa sui dati osservati dai sensori, per spostare la sua traiettoria, al fine di evitare collisioni e raggiungere comunque l'obiettivo. La tipica architettura di navigazione di un robot autonomo é data perciò da quattro moduli, detti anche primitive: 
\begin{description}
\item[Percezione] Prende in input le informazioni derivanti dai sensori, le processa e le restituisce
\item[Localizzazione e Mapping] Con le informazioni sensoriali, il robot costruisce una rappresentazione del proprio intorno basandosi sulla propria posizione e ciò che osserva. Il risultato globale, dopo aver fatto varie osservazioni di intorni diversi, sarà una mappa dell'ambiente, rispetto alla quale il robot può localizzarsi. (Per scopi esemplificativi, questo modulo verrà tralasciato nell'algoritmo di questa tesi, e si userà descrivere la posizione del robot con coordinate assolute e non rispetto ad una mappa.)
\item[Pianificazione] In base alle informazioni sensoriali e cognitive in possesso, produce in output delle decisioni ad un livello di astrazione alto. Nel caso del motion planning, la direttiva da produrre é il percorso da seguire.
\item[Azione] Prende in input le direttive del modulo di pianificazione e produce dei comandi a basso livello per gli attuatori del robot.
\end{description}

\begin{figure}[H]
\caption{Architettura di navigazione}
\centering
\includegraphics[width=0.7\textwidth]{architecture.png}
\label{arch}
\end{figure}

L'architettura utilizzata in questa tesi é la cosiddetta gerarchica: le quattro primitive vengono eseguite in ordine e in loop. È particolarmente indicata per problemi in cui l'obiettivo finale é ben definito a priori. In altre parole, non vi é nessun meccanismo di apprendimento nel robot, ma semplicemente pianificazione deterministica orientata al goal. In figura é visivamente sintetizzato quanto appena detto. In questa tesi viene affrontato un problema che rientra nel terzo modulo: il path planning, un problema di grande importanza e argomento di molta ricerca.

\subsection{Path planning}

Una sua rapida formulazione potrebbe essere la seguente: data la posizione iniziale (del robot) A e una posizione finale B, imposta da chi fa uso del robot, il path planning consiste nel calcolare un percorso fisicamente realizzabile e ottimale per arrivare da A a B.
All'interno dei metodi esistenti (e non), ci sono due importanti distinzioni da fare: sulla formulazione del problema e sulla soluzione al problema.
\begin{description}
\item[La prima] é tra online e offline path planning, o anche locale e globale. Il path planning globale riguarda quelle situazioni in cui l'ambiente considerato é interamente noto a priori, per cui é possibile calcolare il percorso da seguire ancor prima che il robot inizi a muoversi; quello locale é inerente ai casi in cui il robot debba fare i conti lungo il suo percorso con eventi inaspettati, quali ostacoli dinamici,per cui é necessario reagire localmente, aggiornando ripetutamente le informazioni derivanti dai sensori e aggiustando la traiettoria al fine di evitare l'ostacolo e poter raggiungere in tempi ottimali l'obiettivo. Chiaramente, la maggior parte dei problemi di robotica autonome deve fare i conti con una situazione del secondo tipo. 
\item[La seconda] distinzione é tra soluzioni basate su tecniche di intelligenza artificiale - la cui trattazione esula dagli scopi di questa tesi - e soluzioni classiche. Queste ultime possono ulteriormente essere suddivise in \cite{siciliano}:
\begin{itemize}
\item Subgoal (o anche roadmap), la cui realizzazione più nota é il metodo che sfrutta i diagrammi di Voronoi. 
\item Decomposizione in celle
\item Sampling based che frutta un approccio probabilistico.
\item Potenziali artificiali, che verranno ampiamente in trattati nel prossimo capitolo
\end{itemize}
\end{description}

Di seguito si descriverá brevemente degli esempi legati ai metodi appena elencati.

\paragraph{Voronoi} L'idea alla base di questo metodo é rappresentare lo spazio libero delle configurazioni \(C_{free}\), ovvero l'insieme di quei punti che per certo non fanno collidere il robot con un ostacolo, come un grafo, ovvero un insieme di nodi (rappresentati appunto la roadmap) connessi da archi. La posizione dei nodi é definita tramite il concetto di clearance, ovvero la funzione \[\gamma(q) = \min_{s\in\partial C_{free}} \begin{Vmatrix}q-s\end{Vmatrix}\] dove q é una generica configurazione in \(C_{free}\). La clearence é perciò una funzione che ha come valore in ogni configurazione \(q\) la distanza minima tra tutte le distanze da un qualunque punto di un ostacolo. Infatti, \(\partial C_{free}\) sarebbe la frontiera dello spazio di configurazione, ovvero il bordo degli ostacoli. \(C_{free}\) é formato da quelle configurazioni \(q\) tali per cui esiste più di un punto sulla frontiera \(\partial C_{free}\) con lo stesso valore \(\gamma(q)\). In altre parole, quei punti equidistanti (considerando la distanza minima) da più di un ostacolo. Il risultato é quello mostrato in figura \ref{voronoi}. Una volta calcolato il grafo, é sufficiente ritrarre i punti di start e goal sul grafo stesso e calcolare il percorso ottimale tra questi due attraverso un algoritmo di ricerca, ad esempio Djikstra.

\paragraph{Decomposizione esatta in celle} In questa tecnica lo spazio delle configurazioni viene suddiviso in celle, come mostrato in figura \ref{celldecomp}. Ogni cella é delimitata inferiormente e superiormente da un ostacolo e ogni cella ha le seguenti due caratteristiche:
\begin{itemize}
\item Tra ogni coppia di configurazioni nella stessa cella esiste sempre un cammino senza collisioni
\item Tra ogni coppia di celle adiacenti esiste sempre un cammino senza collisioni (che conduce da una cella all'altra)
\end{itemize}
In base a questi due principi, viene costruito il cosiddetto grafo di connettività, che ha come archi le connessioni tra celle adiacenti. Come nel metodo precedente, il calcolo del percorso ottimale per raggiungere il goal consiste nell'applicare un algoritmo di ricerca su grafo.

\begin{figure}[h]
\begin{subfigure}[t]{0.5\textwidth}
\centering
\caption{Diagramma di Voronoi}
\includegraphics[width=\textwidth]{voronoi.png}
\label{voronoi}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.5\textwidth}
\centering
\caption{Decomposizione in celle}
\includegraphics[width=\textwidth]{celldecomp.png}
\label{celldecomp}
\end{subfigure}
\caption{Metodi classici basati su grafo}
\end{figure}

\paragraph{Sampling based} Il terzo metodo si basa su un approccio probabilistico. Brevemente, l'idea é di scegliere a ogni iterazioni una configurazione "di prova" e fare un test di collisione su quest'ultima e si cerca di collegare in basa alla vicinanza alle configurazioni giá appartenenti al grafo che si sta costruendo. \\


La breve descrizione dei metodi serviva anche a motivare la scelta dei potenziali artificiali come base per lo sviluppo dell'algoritmo di navigazione, visto che la totalità dei metodi rientranti nelle prime tre categorie risolve adeguatamente il problema del path planning globale \cite{dalfonso}, ma risulta inefficiente nel caso del path planning locale. Tuttavia, sono particolarmente efficienti nel caso in cui ci si trovi in un ambiente noto a priori, poco incline al cambiamento e con l'esigenza di fare query ripetute. Il costo computazionale é quasi tutto contenuto nel calcolo del grafo, e la singola query ha un costo legato al numero di archi.\\
Come da titolo, questa tesi ha come obiettivo specifico quello di esporre un lavoro di progettazione, implementazione e simulazione di un algoritmo di path planning \textbf{locale} basato su \textbf{switching} tra \textbf{potenziali artificiali}. 

\subsection{Formalizzazione del problema} \label{problema}

Chiamerò \( r(t) = [x_r(t),y_r(t),\theta_r(t)]^T\) la posizione del robot nell'istante t (per semplicità di notazione, ove necessario, si ometterà la dipendenza dal tempo nelle formule) e \( O_i(t) = [x_{O,i}(t),y_{O,i}(t)]^T, i = 1...N\) la posizione degli N ostacoli che, per scopi esemplificativi in fase di prototipazione dell'algoritmo, saranno di forma circolare e con raggio \(R_i\). Quest'ultima ipotesi non provoca una perdita di generalità, visto che per un ostacolo di forma generica si può considerare la sua circonferenza circoscritta. Esisterà inoltre un punto \(G = [G_x, G_y]\) che indica l'obiettivo del robot. Il problema consiste nel voler raggiungere il punto \(G\) dalla posizione iniziale \(r(0)\), tenendo conto degli \(N\) ostacoli in movimento. Il robot é dotato di un raggio di visione di \(R_v\) metri, entro il quale é capace di rilevare un ostacolo. Inoltre, si presuppone che valga la seguente condizione
\[\begin{Vmatrix}\begin{bmatrix} x_r(t)\\ y_r(t) \end{bmatrix} - O_j(t)\end{Vmatrix} \leq R_v \], ovvero \( R_i \leq R_v, \forall i\). Ciò vuol dire che nel momento in cui il robot incontra un ostacolo, il centro di quest'ultimo é incluso in \(R_v\).

\subsection{Organizzazione della tesi} 
Nella sezione subito dopo si parlerà del metodo dei potenziali artificiali e si motiverà la scelta di utilizzarli per il path planning. Successivamente verrà affrontato l'algoritmo vero e proprio, per il quale é usato un approccio top-down nella progettazione e quindi anche nell'esposizione nella tesi: prima si affronta in una modalitá "bird-view" come é organizzato nel software, affrontando come i diversi moduli interagiscono tra di loro per ottenere l'obiettivo finale, senza scendere in dettagli implementativi. Successivamente, sempre in una logica top-down, si affrontano (con riferimento alla figura \ref{arch}) i singoli moduli : per primo l'ambiente e come viene rappresentato, dopo il modulo di azione, poi pianificazione e poi percezione. Ogni modulo, quindi, viene trattato dando per scontato di avere già accesso al modulo "inferiore" che gli fornisce dati in input. I moduli, infatti, sono stati progettati indipendentemente gli uni dagli altri.

\newpage
\section{Potenziali artificiali}

Metodo introdotto per la prima volta negli anni 90 da Oussama Khatib, é tanto semplice quanto efficace per risolvere il problema del path planning. Si differenzia dai metodi precedentemente menzionati per il fatto che la traiettoria non viene costruita "attivamente", nel senso che non vengono definiti dei punti di passaggio che formano una traiettoria ottimale. Piuttosto quello che si fa é, mediante l'interazione con i cosiddetti potenziali artificiali, cercare una \textbf{configurazione ottimale}. Quindi, la traiettoria viene costruita mentre il robot si muove, motivo per cui é un metodo adatto al path planning locale.

\subsection{Metodo classico}
Tradizionalmente, nel path planning basato su potenziali artificiali il robot viene fatto muovere mediante una funzione in due variabili, ovvero un potenziale scalare, che nasce dalla somma di due potenziali: attrattivo e repulsivo. Questi due potenziali sono chiamati artificiali perché generano una forza che guida il robot in ogni sua configurazione \(r\), nonostante nella realtà non vi sia nessuna sorgente a generare quella forza. Nello specifico, la forza generata dal potenziale é il suo antigradiente, ovvero il gradiente cambiato di segno, che indica al robot la direzione di moto localmente più promettente\cite{oriolo}, cioè verso il punto di minimo della funzione. Di conseguenza il potenziale attrattivo assume una forma tale da avere un unico punto di minimo posizionato proprio nel punto di arrivo, mentre il repulsivo ha un unico punto di massimo corrispondente alla posizione dell'ostacolo. Nello specifico, ciò é di solito realizzato grazie alla funzione della configurazione del robot
\begin{equation}
e(r) = G - \begin{bmatrix} x_r(t)\\ y_r(t) \end{bmatrix}
\end{equation}
che misura l'errore tra la posizione del robot e il goal. L'idea dietro al potenziale attrattivo é di generare una funzione che sia direttamente proporzionale a \(e(r)\), e quindi assuma valori elevati lontano dal goal e valori bassi vicino al goal, creando così un punto di minimo nel goal stesso.

\begin{description}
\item[Il potenziale attrattivo] ha di solito la forma mostrata in figura \ref{potA}, in cui il punto di minimo, ovvero il goal, ha coordinate \([1,1.5]\).
\begin{figure}[H]
\centering
\caption{Potenziale attrattivo}
\includegraphics[width=0.8\textwidth]{potA.png}
\label{potA}
\end{figure}

La funzione corrispondente é

\begin{equation}
U_{a1}(r,G) = \frac{1}{2} \cdot k_1 ||e(r)||^2
\end{equation}

Il suo antigradiente di conseguenza é formato da tanti vettori che, con un'intensità proporzionale alla distanza dal goal, puntano verso quest'ultimo.
\begin{figure}[H]
\centering
\caption{Antigradiente del potenziale attrattivo}
\label{antigradA}
\includegraphics[width=0.6\textwidth]{antigradA.png}
\end{figure} 
Matematicamente si esprime come il vettore delle derivate parziali (del potenziale) cambiato di segno, ovvero 
\begin{equation}
-\nabla U_{a1}(r,G) = k_1 e(r)
\end{equation}
Perciò, la forza esercitata dal potenziale sul robot punta verso il goal e converge a zero quando la configurazione \(r(t)\) tende alla destinazione \(G\), esprimendo difatti un errore lineare tra goal e posizione del robot.\\
Oltre al potenziale paraboloide si può optare anche per un potenziale conico 
\begin{equation}
U_{a2}(r,G) = k_2||e(r)||
\end{equation}
e, come si può anche vedere in figura \ref{potACon}, la riduzione dell'errore all'avvicinarsi del robot al goal non é più quadratica, ma lineare. Da ciò scaturisce un comportamento più "smooth" lontano dal goal (la velocità é meno elevata rispetto al potenziale paraboloide). Tuttavia, vicino al goal é conveniente usare quest'ultimo, per raggiungere la posizione esatta con minore velocità, il che conferisce più precisione al movimento del robot. 
\begin{figure}[H]
\centering
\caption{Potenziale attrattivo}
\includegraphics[width=0.8\textwidth]{potACon.png}
\label{potA}
\end{figure}
L'antigradiente del potenziale conico ha la seguente espressione
\begin{equation}
-\nabla U_a(r,G) = k_2\frac{e(r)}{||e(r)||}
\end{equation}

L'idea é quella di stabilire una soglia per la funzione errore oltre (e su) la quale, avvicinandosi al goal, il potenziale attrattivo sarà di forma paraboloide. 
Dunque il potenziale attrattivo finale sarà del tipo
\begin{equation}
\label{potAC}
U_a(r) = 
\begin{cases}
\frac{1}{2} \cdot k_1 ||e(r)||^2 \quad &||e(r)|| \leq \rho \\
k_2||e(r)|| \quad &||e(r)|| > \rho
\end{cases}
\end{equation}

dove \(\rho\) é la soglia.  Gli scalari k e la soglia andranno scelti in maniera tale da garantire continuità nel passaggio da un potenziale attrattivo all'altro. In particolare deve valere che la velocità imposta dall'antigradiente al robot proprio nel punto di soglia deve essere la stessa per entrambi i potenziali, ovvero
\[k_1 \cdot e(r) = k_2 \cdot \frac{e(r)}{||e(r)||} \Leftarrow ||e(r)|| = \rho\]
da cui segue che 
\begin{equation}
\label{parconswitch}
k_1 \cdot \rho = k_2 
\end{equation}

\item[Il potenziale repulsivo] ha una forma duale a quello attrattivo, come mostrato in figura \ref{potR}. Esso impone che entro uno distanza \(\eta\) dall'ostacolo per il quale lo si sta calcolando, la sua funzione avrà valore inversamente proporzionale alla distanza dall'ostacolo stesso. Praticamente, più ci si avvicina all'ostacolo entro una certa soglia \(\eta\), più l'intensità del potenziale artificiale, perciò anche della forza generata da esso, aumenta.

\begin{figure}[H]
\begin{subfigure}[t]{0.5\textwidth}
\caption{Potenziale repulsivo}
\includegraphics[width=\textwidth]{potR.png}
\label{potR}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.5\textwidth}
\caption{Antigradiente del potenziale repulsivo}
\label{antigradR}
\includegraphics[width=\textwidth]{antigradR.png}
\end{subfigure}
\caption{Potenziale repulsivo}
\end{figure}

Al potenziale repulsivo corrisponde la seguente funzione a tratti 

\begin{equation}
\label{potREq}
U_r(r(t),O_j(t)) = 
\begin{cases}
\frac{1}{2} \left( \frac{1}{d(r(t),O_j(t)} - \frac{1}{\eta} \right) \quad &d(r(t),O_j(t)) \leq \eta \\
0 \quad &altrimenti
\end{cases}
\end{equation}
dove \[ d(r(t),O_j(t) = \begin{Vmatrix}O_j(t) - \begin{bmatrix} x_r(t)\\ y_r(t) \end{bmatrix}\end{Vmatrix}\]

Dunque, il compito della forza generata é quello di spingere via il robot dalla posizione dell'ostacolo tanto più che il robot si avvicina entro la soglia \(\eta\) a quest'ultimo. In figura \ref{antigradR} si vedono le linee di campo dell'antigradiente che puntano radialmente verso l'esterno rispetto alla posizione dell'ostacolo, qui con coordinate \([1.5, 1]\).
\end{description}

Una volta calcolato il potenziale repulsivo per ogni singolo ostacolo, si ottiene il potenziale totale:

\begin{equation}
\label{antigradeq}
U(r(t)) = U_a(r(t),G) + \sum_{j=1}^{n} U_r(r(t),O_j(t))
\end{equation}

In figura \ref{pot} si vede un possibile percorso del robot per arrivare dal punto di partenza al goal. Dalla \ref{antigradeq} si vede che l'antigradiente è una funzione di \(r(t)\): vuol dire che in ogni sua configurazione, siccome l'antigradiente si suppone già calcolato, il robot può ottenere informazioni su quest'ultimo riferendosi soltanto alla sua stessa posizione. Quindi, il vettore velocità del robot \([v_x(t) , v_y(t)]\) ha come riferimento in ogni istante t il valore dell'antigradiente (che é un vettore) in \([r_x(t),r_y(t)]\). Lontano dagli ostacoli, il vettore velocità ha una direzione che punta al goal e un'intensità che diminuisce man mano che ci si avvicina al goal. Più il robot si avvicina ad un ostacolo, più la direzione del vettore velocità vira verso il verso opposto rispetto a \(\theta = \tan \left( \frac{y_{O,j}(t)-y_r(t)}{x_{O,j}(t)-x_r(t)} \right) \) (ovvero la direzione del vettore che collega il robot all'ostacolo), spostando così temporaneamente la traiettoria desiderata e aumentando "l'intensità della virata" lontano dall'ostacolo man mano che si avvicina ad esso. Il robot dunque, seguendo l'antigradiente, viene in ogni sua configurazione \(r(t)\) - usando l'analogia con il campo gravitazionale - attratto dal goal e \textbf{contemporaneamente} respinto dagli ostacoli. Chiaramente, il metodo é idoneo sia al path planning globale che a quello locale (basta ricalcolare il potenziale totale in presenza di ostacoli). Volendo, d'altra parte, dare un'etichetta dal punto di vista dell'architettura di navigazione, i potenziali artificiali tradizionali obbediscono ad una di tipo reattivo: considerando la figura \ref{arch}, il modulo di mapping e path planning sono praticamente assenti. Gli attuatori del robot, che sono collegati ai sensori tramite una funzione di trasferimento \cite{kim}, ricevono direttamente il comando derivante dal calcolo precedente del potenziale artificiale, senza alcun tipo di pianificazione algoritmica. 

\begin{figure}[H]
\centering
\caption{Potenziale totale}
\label{pot}
\includegraphics[width=0.7\textwidth]{pot.png}
\end{figure}

Tuttavia, nonostante la sua semplicità ed efficacia, vi sono delle non-idealità legate a questo approccio. Ad esempio, la traiettoria potrebbe non essere continua. Il potenziale repulsivo non é "coordinato" con quello attrattivo, perciò il robot potrebbe ricevere comandi che causerebbero un cambio di direzione o di velocità troppo repentino che andrebbe gestito dalla legge di controllo o un modulo di pianificazione apposito. Questa osservazione verrà trattata nel capitolo riguardante l'algoritmo di navigazione. \\
Altro problema da considerare é il fatto che il robot viene "passivamente" spinto via dagli ostacoli senza la certezza che venga portato in una posa in cui può effettivamente evitare con successo l'ostacolo.\\
Ma il più importante, sicuramente, é il problema dei minimi locali: il robot non ha alcuna informazione su come uscirne, né può prevederli in anticipo. I minimi locali sono dei punti ad antigradiente nullo (i gradiente del potenziale attrattivo e repulsivo possono annullarsi a vicenda), dove il robot non ha nessuna forza a guidarlo verso il goal, situazione che dovrebbe verificarsi soltanto nel punto di goal stesso. In figura \ref{minloc} viene mostrato il percorso simulato di un robot in presenza di un minimo locale nel potenziale artificiale. Il robot parte dalla posizione \(r(0) = [5,0]\) mentre il goal si trova in posizione \(G = [5,10]\). Gli ostacoli sono posizionati tra il robot e il goal ad una distanza tale da causare un annullamento del gradiente (quindi il minimo locale) proprio a metà tra i due, lì dove il robot cerca di passare. La traiettoria del robot, infatti, si ferma nel minimo locale: non viene spinto da nessuna forza e "crede" di essere arrivato nel punto di goal.
\begin{figure}[H]
\begin{subfigure}[t]{0.5\textwidth}
\caption{Potenziale con minimo locale}
\includegraphics[width=\textwidth]{minimoLocale.png}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.5\textwidth}
\caption{Antigradiente del potenziale con minimo locale}
\includegraphics[width=\textwidth]{antigradMinimoLocale.png}
\end{subfigure}
\caption{Minimo locale}
\label{minloc}
\end{figure}

\subsection{Potenziale bypassante}
Al fine di evitare le non-idealità dovute all'utilizzo dei potenziali sommati, l'idea implementata in questa tesi é quella di sfruttare al posto di quello repulsivo un altro tipo di potenziale che chiameremo bypassante. Fondamentalmente, si tratta di un potenziale che invece di spingere via il robot dall'ostacolo, lo porta a circumnavigarlo. Infatti, le linee di campo dell'antigradiente di questo potenziale sono concentriche, al contrario di quelle del potenziale repulsivo che sono radiali. L'idea quindi é di basarsi su una superficie che ruoti attorno a un centro, identificato dalla posizione, ad esempio un elicoide:

\begin{equation}
\begin{cases}
x = x_0 + r cos(\xi) \\
y = y_0 + r sin(\xi)  \\
z = c \xi
\end{cases}
\end{equation}

Applicando nella terza equazione la tangente da entrambe le parti, otteniamo \(\tan(\xi)=\tan(\frac{z}{c})\) che, confrontando con le prime due equazioni, diventa
\[\tan \left( \frac{z}{c} \right) = \frac{y-y_0}{x-x_0}\] dove \([x_0,y_0]\) sarebbe la posizione dell'ostacolo. Invertendo questa funzione per esprimerla come z in funzione di x e y, otteniamo il potenziale elicoidale, ridenominato bypassante, in senso orario rispetto all'ostacolo e centrato in esso:

\begin{equation}
\label{potBeq}
\Gamma(x,y,x_0,y_0) = c\tan^{-1} \left( \frac{y-y_0}{x-x_0} \right)
\end{equation}

\begin{figure}[H]
\begin{subfigure}[t]{0.5\textwidth}
\caption{Elicoide centrato in \([1,1]\) \\ con \(c=2\), \(0\leq r \leq 1\) e \(0 \leq \xi \leq 4\pi\)}
\includegraphics[width=\textwidth]{elicoide.png}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.5\textwidth}
\caption{Potenziale bypassante centrato in \([1,1]\) con \(c=2\) e in senso orario}
\includegraphics[width=\textwidth]{potB.png}
\label{potB}
\end{subfigure}
\caption{Potenziale bypassante}
\end{figure}

Da notare che il potenziale in figura \ref{potB} ha una discontinuità per \(x=x_0\), per cui la funzione é continua per \((x,y) \neq (x_0,y_0)\). Siccome il robot non può mai andare esattamente nella stessa posizione dell'ostacolo, non c'è perdita di generalità nell'ignorare la discontinuità e di conseguenza il robot sarà sempre in grado di seguire la forza generata dal potenziale. Il potenziale con equazione \ref{potBeq} può essere visto come una funzione della posizione del robot e dell'ostacolo da aggirare \[\Gamma(x,y,x_0,y_0) = \Gamma(x_r(t),y_r(t),x_{O,j}(t),y_{O,j}(t))\] Dunque, la forza generata dal potenziale bypassante é esprimibile come il suo antigradiente

\begin{equation}
-\nabla U_b(r(t),O_j(t)) =
\begin{bmatrix}
\frac{c(y_r(t)-y_{O,j}(t))}{(x_r(t)-x_{O,j}(t))^2 + (y_r(t)-y_{O,j}(t))^2} \\\\
\frac{c(x_{O,j}(t) - x_r(t))}{(x_r(t)-x_{O,j}(t))^2 + (y_r(t)-y_{O,j}(t))^2}
\end{bmatrix}
\end{equation}\\

Quindi, l'antigradiente é formato da tanti vettori che
\begin{itemize}
\item Indicano una velocità desiderata nella posa \(r(t)\) del robot, al fine di aggirare l'ostacolo preso in considerazione  \item Aumentano di intensità man mano che il robot si avvicina all'ostacolo
\item Hanno forma concentrica
\end{itemize}

\begin{figure}[H]
\centering
\caption{Antigradiente del potenziale bypassante}
\label{antigradB}
\includegraphics[width=0.8\textwidth]{antigradB.png}
\end{figure}

Questo tipo di potenziale, chiaramente, é intrinsecamente adatto ad ostacoli di forma circolare, motivo per cui nel lavoro di tesi si é considerato soltanto questo tipo di ostacoli.

\section{Panoramica sull'algoritmo di navigazione} 
La strategia é semplice: nella posizione iniziale, il robot sonda l'ambiente attorno a sé: se non vi sono presenti ostacoli a impedirne l'avanzamento verso il goal, la traiettoria da seguire é quella imposta dal potenziale attrattivo; altrimenti é necessario \textbf{"switchare"} dal potenziale attrattivo a quello bypassante, al fine di aggirare l'ostacolo, per poi tornare a seguire la traiettoria dell'antigradiente attrattivo. Perciò, la peculiarità di questo algoritmo é che in ogni istante di tempo il robot seguirà \textbf{un solo potenziale} alla volta, evitando così il problema dei minimi locali discusso in precedenza. Inoltre, le informazioni necessarie a pianificare lo switch non richiedono informazioni globali, ma solo di tipo \textbf{locale} relative all'ostacolo da aggirare. Nella figura \ref{flow} si vede, orientativamente, come funziona l'algoritmo. 

\begin{figure}[H]
\caption{Flowchart Diagram} \label{flow}
\centering
\includegraphics[width=0.7\textwidth]{flowchart.png}
\end{figure}

Le pseudo-istruzioni in giallo sono quelle relative al modulo di pianificazione e le verdi al modulo di visione. Naturalmente verranno approfonditi nelle rispettive sezioni. Una considerazione sull'istruzione rossa, relativa al modulo di azione: avanzare per un dt é indice del fatto che é stato usato nel progetto un approccio completamente discretizzato (questo aspetto viene approfondito nel paragrafo successivo).


\subsection{Organizzazione del software}

In figura \ref{class} é riportato il class diagram del software di navigazione. La classe Act e Sense rappresentano rispettivamente il modulo di azione e pianificazione. Il modulo di pianificazione é costituito dalla gerarchia discendente dalla classe astratta RobotState. SwitchingRobot é la classe che incapsula i tre moduli e ne fa uso all'interno di un suo "main" che é il metodo start.
\begin{figure}[H]
\centering
\label{class}
\caption{Class diagram}
\includegraphics[width=\textwidth]{classDiagram.png}
\end{figure}
Quindi, per capire meglio come le classi sono collegate tra di loro, nel seguente codice, che si trova appunto nella classe SwitchingRobot, é illustrato il funzionamento dell'algoritmo dal punto di vista del robot, che, come é facile vedere, é completamente disaccoppiato dalle implementazioni concrete dei singoli moduli di navigazione.
\begin{lstlisting}
function obj = start(obj)
	%Simulation data
	e = norm([obj.xc,obj.yc]-obj.grid.goal);
	tspan = 0.05; tsim = 0; samples = 0;
	%Starting simulation
	while(e > 0.1 && tsim < 20)
		%Sensed obstacle (empty array if nothing was sensed)
		dObstacle = obj.sense.scan(obj);
		%New directive
		obj.state.decision(obj,dObstacle);
		%Giving the command to the actuators 
		[obj.xc,obj.yc,obj.theta] = obj.act.move(obj,tspan);
		%Refreshing the error
		e = norm([obj.xc,obj.yc]-obj.grid.goal); 
		tsim = tsim + tspan; pause(0);
	end
end
\end{lstlisting}

L'idea é che il robot proceda in maniera discreta, ovvero che faccia dei campionamenti in istanti equidistanti e si muova di conseguenza. Fa da "guida" il ciclo while, il cui "indice di scorrimento" é l'errore \(e\) tra robot e goal. Altra variabile importante é \(tspan\) che indica il tempo tra un istante di campionamento e il successivo, dove con campionamento si intende, volgarmente, uno "snapshot" dell'intorno da parte del modulo di visione. Come si vede nel codice, il meccanismo attuato ad ogni iterazione é molto semplice: dapprima si controlla se é stato rilevato un ostacolo attraverso il metodo scan della classe Sense. Successivamente la variabile dObstacle, che é vuota se non viene rilevato nessun ostacolo, viene passata al metodo decision. Quest'ultimo viene richiamato sul campo state, a cui si può assegnare l'intera gerarchia erede di RobotState, per cui, a seconda dell'oggetto assegnato a state, il risultato restituito dal metodo decision sarà diverso (é qui che avviene il meccanismo di switching tra potenziali artificiali che verrà approfondito nella sezione relativa al modulo di pianificazione). Infine, una volta che il robot ha preso una decisione, passa il comando al modulo di azione per potersi effettivamente muovere attraverso il metodo move della classe Act (si approfondirà questo metodo in merito alla simulazione). Questo ciclo si ripeterà naturalmente fino a che il robot non sarà arrivato nel punto di goal.

\section{Rappresentazione dell'ambiente}
Prima di affrontare i moduli che guidano il robot nell'ambiente circostante, ha senso chiedersi, a questo punto, come questo possa esser rappresentato, sopratutto in relazione ai potenziali artificiali. La scelta fatta in questa tesi é stata quella di rappresentare l'ambiente in maniera completamente discretizzata. Ciò che lo circonda é per il robot una matrice (nel linguaggio di Matlab una meshgrid) in cui ogni cella corrisponde a un \(dx\cdot dy\) del mondo reale. Di conseguenza, il potenziale artificiale sarà una funzione che si concretizza in una matrice della stessa dimensione della meshgrid (il calcolo dell'antigradiente sarà affrontato nel modulo di pianificazione). Ogniqualvolta il robot voglia calcolare il valore dell'antigradiente in un punto di coordinate \([x,y]\), bisogna convertire queste in indici della meshgrid. Ciò viene fatto dal metodo coord2index della classe Grid.
\begin{lstlisting}
function index = coord2index(obj,point)
	index = zeros(1,2);
	% x coordinate goes into the column index
	floorx = floor(point(1));
	index(2) = (floorx + obj.dx*floor((point(1) - floorx)/
		obj.dx))*obj.resolution + 1;
	% y coordinate goes into the row index
	floory = floor(point(2));
	index(1) = (floory + obj.dx*floor((point(2) - floory)/
		obj.dx))*obj.resolution + 1;
	index = floor(index);
end
\end{lstlisting}

\begin{nota}
\textbf{Nota}\\ Si é scelto, in merito alla rappresentazione dell'ambiente, di non sfruttare una griglia di occupazione binaria per gli ostacoli. Questo rende il modulo di visione un po' "fittizio", nel senso che esso fa lo "snapshot" semplicemente andando a vedere la posizione degli ostacoli nella classe Grid, cosa che nella realtà non avviene. Questa semplificazione non é senza perdita di generalità, poichè basta ,appunto, aggiungere una griglia di occupazione binaria accessibile dal modulo di visione tramite un sensore lidar. In ogni caso, ciò che é importante dell'implementazione discretizzata é il metodo per passare da coordinate reali a coordinate della meshgrid.
\end{nota}


\section{Modulo di azione}
Il modulo responsabile per il movimento del robot riceve in input un comando dal modulo di pianificazione, ovvero l'antigradiente da seguire, e restituisce in output una "traduzione" del comando in una velocità da imporre agli attuatori (tramite una legge di controllo), tenendo conto dello specifico modello cinematico del robot. 
\begin{figure}[h]
\centering
\caption{Modello Differential-Drive \cite{toolbox}} \label{dd}
\includegraphics[width=0.8\textwidth]{DD.png}
\end{figure}

\subsection{Modello cinematico}
Si é ipotizzato in questa tesi di usare un modello cinematico anolonomo di tipo differential drive. Il fatto che sia anolonomo vuol dire che obbedisce ad un vincolo sulla velocitá e non sulla posizione, ovvero \[\theta(t) = \arctan \left( \frac{\dot{y}(t)}{\dot{x}(t)} \right) \] Praticamente, al robot é impossibile muoversi in ogni direzione con la stessa velocità; per mantenerla, deve continuare a mantenere il suo orientamento invariato. Le equazioni differenziali che modellano un generale robot che obbedisce a vincolo anolonomo é
\begin{equation}
\label{anolomeq}
\begin{cases}
\dot{x}(t) = v(t)\cos(\theta(t)) \\
\dot{y}(t) = v(t)\sin(\theta(t)) \\
\dot{\theta}(t) = \omega(t)
\end{cases}
\end{equation} 
Quindi, secondo questo modello, un robot può essere completamente caratterizzato mediante la sua posizione \([x,y,\theta]\) e la sua velocità \([v,\omega]\), dove \(v\) indica la velocità lineare (di traslazione) e \(\omega\) quella angolare (di rotazione).\\
In particolare, nel modello differential drive il robot, come mostrato in figura \ref{DD}, viene mosso da due ruote laterali (ogni ruota ha il suo motore) di raggio \(R\), posizionate sullo stesso asse e distanti tra di loro \(L\). Detto ciò, si può scrivere la velocità lineare come la media tra le velocità lineari delle due ruote \[v(t)=\frac{R\cdot\omega_R(t)+R\cdot\omega_L(t)}{2}\] e quella angolare come la differenza tra le due velocità lineari normalizzata per la distanza tra le ruote \[\omega(t)=\frac{R\cdot\omega_R(t)-R\cdot\omega_L(t)}{L}\] Riunite in forma matriciale, queste due relazioni danno la seguente
\begin{equation}
\begin{bmatrix}
v(t) \\
\omega(t)
\end{bmatrix}
=
\begin{bmatrix*}[r]
\frac{R}{2} & \frac{R}{2} \\
\frac{R}{L} & -\frac{R}{L}
\end{bmatrix*}
\begin{bmatrix}
\omega_R(t) \\
\omega_L(t)
\end{bmatrix}
\end{equation} 

Invertendo questa relazione, si può ottenere la velocitá delle due ruote a partire dalla velocità lineare e angolare di riferimento.
\begin{equation}
\label{wrwl}
\begin{bmatrix}
\omega_R(t) \\
\omega_L(t)
\end{bmatrix}
=
\begin{bmatrix*}[r]
\frac{R}{2} & \frac{R}{2} \\
\frac{R}{L} & -\frac{R}{L}
\end{bmatrix*}^{-1}
\begin{bmatrix}
v(t) \\
\omega(t)
\end{bmatrix}
\end{equation}

Questa inversione é sempre possibile, visto che
\[det\begin{bmatrix*}[r]
\frac{R}{2} & \frac{R}{2} \\
\frac{R}{L} & -\frac{R}{L}
\end{bmatrix*} = \frac{-R^2}{L}\] che é sempre non nullo, per cui la matrice é invertibile.

Dunque, il modello \ref{anolomeq} diventerá
\begin{equation}
\label{DDeq}
\begin{cases}
\dot{x}(t) = \frac{R}{2} \left( \omega_R(t)+\omega_L(t) \right) \cos(\theta(t)) \\
\dot{y}(t) = \frac{R}{2} \left( \omega_R(t)+\omega_L(t) \right)\sin(\theta(t)) \\
\dot{\theta}(t) = \frac{R}{L} \left( \omega_R(t)-\omega_L(t) \right)
\end{cases}
\end{equation} 

\subsection{Legge di controllo}

Nel caso specifico del path planning con potenziali artificiali, la velocità di riferimento é data dall'antigradiente relativo alla posa del robot, cioè \(v_\nabla(t) = -\nabla U(r(t))\). Con la legge di controllo viene stabilita una velocità lineare e angolare da imporre al robot e viene stabilito che
\begin{equation}
v(t) = M_v \cos(\theta_{\nabla}(t) - \theta_r(t))
\end{equation} 
\begin{equation}
\omega(t) = K_{\omega}(\theta_{\nabla}(t) - \theta_r(t))
\end{equation} dove \(M_v=\begin{Vmatrix}v_{\nabla}(t)\end{Vmatrix}\), \(\theta_{\nabla}=\angle v_{\nabla}(t)\) e 
\[K_{\omega}(t)= \begin{cases}
\frac{\dot{\theta}_{\nabla}(t) + K_c|\theta_{\nabla}(t)-\theta_r(t)|^{\nu} \cdot sign(\theta_{\nabla}(t) - \theta_r(t))}{\theta_{\nabla}(t) - \theta_r(t)} \quad &|\theta_{\nabla}(t)-\theta_r(t)| \geq \xi \\
0 \quad &altrimenti
\end{cases}\]

Una volta calcolate le velocità di riferimento \(v(t)\) e \(\omega(t)\), basta applicare la relazione \ref{wrwl} per avere le velocitá di riferimento relative alle due ruote del differential drive, ottenendo cosí i comandi da impartire agli attuatori del robot.\\
La legge di controllo, specifica per questo metodo di navigazione, é implementata nel metodo commands. Quest'ultimo si trova nella classe APFAct (erede di Act) dove APF sta per artificial potential fields, il che vuol dire APFAct é idoneo a mobilitare tutti quei robot che sfruttano potenziali artificiali, indipendentemente dal modello cinematico. In output, il metodo commands restituisce le due velocità (lineare e angolare), che vengono poi convertite in altre due velocità (\((w_R\) e \(w_L)\) che sono gli effettivi comandi da attribuire ai motori che fanno girare le due ruote. In particolare, si possono notare due aspetti importanti:
\begin{itemize}
\item Le velocità desiderate (vGrad) sono, dopo aver prelevato gli antigradienti dallo stato attualmente in funzione del robot, calcolate nella posizione del robot tramite la funzione coord2index
\item \(\dot{\theta}_{\nabla}(t)\) viene calcolato per via numerica da riga 11 a 16
\end{itemize}

\begin{lstlisting}
function [vr,wr] = commands(~,rx,ry,rtheta,tspan,robot)
	grid = robot.grid; 
	gradX = robot.state.gradX; gradY = robot.state.gradY;
	i = grid.coord2index([rx,ry]);
	thetaN = atan2(gradY(i(1),i(2)),gradX(i(1),i(2)));
	thetaDiff = atan2(sin(thetaN-rtheta),cos(thetaN-rtheta));
	vgrad = [gradX(i(1),i(2)) gradY(i(1),i(2))];            
	Mv = norm(vgrad);
	vr = (Mv * cos(thetaDiff));
      
	rx1 = rx + vgrad(1)*tspan;
	ry1 = ry + vgrad(2)*tspan;
	j = grid.coord2index([rx1,ry1]);
	thetaN1 = atan2(gradY(j(1),j(2)),gradX(j(1),j(2)));   
	thetaDdiff = atan2(sin(thetaN1-thetaN),cos(thetaN1-thetaN));
	thetaDdot = thetaDdiff/tspan;
	
	Kc = 10; eps = 0.001; v = 1;
	Kw = (thetaDdot + Kc * abs(thetaDiff)^v * ...
	sign(thetaDiff))/(thetaDiff+eps);
	wr = (abs(thetaDiff) >= eps) * Kw * (thetaDiff);
end
\end{lstlisting}

\newpage
\section{Modulo di pianificazione}
Il modulo di pianificazione riceve ad ogni iterazione in input i dati processati dai sensori e in base a ciò decide a quale potenziale il robot deve fare riferimento, inoltrando successivamente la decisione al modulo di azione. 
\begin{nota}
\textbf{Nota implementativa} \\ Il modulo di pianificazione, argomento principe della tesi, é stato sviluppato indipendentemente dagli altri. Cioè, come preannunciato nella sezione \ref{problema}, si presuppone che il robot conosca in ogni istante la propria posizione e quella degli ostacoli all'interno del raggio di visione, come anche le loro velocità. Tale ipotesi semplificativa non provoca una perdita di generalità, grazie soprattutto al fatto che il software é stato progettato per essere modulare e con basso accoppiamento. Si parlerà meglio di questo aspetto nella sezione riguardante il modulo di visione.
\end{nota}
Data la struttura intrinseca dell'algoritmo di navigazione che si basa su un meccanismo di switching tra due stati, per definizione mutuamente esclusivi, un modo per modellare visivamente il pianificatore é sicuramente uno statechart diagram, come riportato in figura \ref{state}. Il robot può trovarsi, in una logica aut aut, nello stato corrispondente al potenziale attrattivo oppure in quello relativo al potenziale bypassante.

\begin{figure}[H]
\caption{Statechart Diagram} \label{state}
\includegraphics[width=\textwidth]{statechart.png}
\end{figure}

La strategia più naturale, sul piano dell'ingegneria del software, é di sfruttare il design pattern State per modellare correttamente il comportamento del robot. Ne consegue che gli oggetti di tipo SwitchingRobot hanno un campo RobotState che incapsula il comportamento relativo ad uno specifico antigradiente e quindi responsabile di gestire i comportamenti \textbf{state-specific}. Perciò, RobotState si configura come un'interfaccia che offre all'esterno il metodo decision (già visto nel listing \ref{start}), il quale prende in input il robot e l'ostacolo rilevato. RobotState contiene aanche l'antigradiente come variabile d'istanza: com'è naturale aspettarsi, ogni stato (attrattivo, bypassante ecc) possiede un specifico antigradiente. 
\begin{lstlisting}
classdef (Abstract) RobotState < handle
    properties
        gradX; gradY;
    end
    
    methods (Abstract)
        obj = decision(obj,robot,dObstacle);
    end
end
\end{lstlisting}
Il metodo decision, in pratica, decide se operare o meno uno switch del campo state (riportato di seguito tra i campi della classe SwitchingRobot).
\begin{lstlisting}
properties
	act APFAct = APFAct();
	sense Sense = Sense();
	state RobotState = DefaultRobotState();
	attractive Attractive;
end
\end{lstlisting}

\subsection{Stato attrattivo}
Lo stato iniziale del robot é quello attrattivo, conseguente all'imposizione del goal e il calcolo del potenziale attrattivo. Com'è prassi per il pattern State, ogni comportamento state-specific é incapsulato in una classe a parte. In questo caso specifico, la ridefinizione del comportamento specifico consiste nel ridefinire il metodo decision e calcolare gradX e gradY. Come riportato nel listing di seguito, se il robot si trova nello stato attrattivo, esso deve controllare innanzitutto se è stato rilevato un ostacolo, ed eventualmente prepararsi per bypassarlo. Il costruttore di VirtualBypassing é il metodo che calcola il potenziale bypassante e verrà trattato nel paragrafo successivo. Una volta calcolato il nuovo stato da assegnare al robot, viene richiamato il metodo setState che cambia il campo state dell'oggetto robot passato in input. 
\begin{lstlisting}
classdef Attractive < RobotState
	methods
		function obj = decision(obj,robot,dObstacle)
			if ~isempty(dObstacle)
				bypassing = VirtualBypassing(robot,dObstacle);
				bypassing.obstacle = [dObstacle.xc dObstacle.yc];
				robot.setState(bypassing);
			end
		end
	end
end
\end{lstlisting}
Come discusso nel capitolo sui potenziali artificiali, il potenziale attrattivo sarà conico fino a che \(e(r) > 1\). Infatti, vediamo che nel costruttore di SwitchingRobot, il potenziale attrattivo viene inizializzato a Conical.
\begin{lstlisting}
function obj = SwitchingRobot(R,L,grid)
	obj@Robot(R,L,grid);
	obj.state = Conical(grid);
	obj.attractive = obj.state;
end
\end{lstlisting}
Nel costruttore di Conical é implementata l'equazione \ref{potAC} con \(k_2=1\). Quindi, nel momento in cui viene costruito l'oggetto SwitchingRobot, gli viene subito assegnato un potenziale attrattivo di tipo conico. L'implementazione a oggetti rende il software molto flessibile, poiché SwitchingRobot é indipendente dal potenziale che possiede. 
\begin{lstlisting}
function obj = Conical(grid)
	di = sqrt((grid.goal(1)-grid.X).^2 +
		 (grid.goal(2)-grid.Y).^2);
	obj.gradX = (grid.goal(1)-grid.X)./di; 
	obj.gradY = (grid.goal(2)-grid.Y)./di;
end
\end{lstlisting}
Nel caso del potenziale attrattivo conico vi sono due azioni da compiere: primo, eseguire l'implementazione di decision della classe padre di tutti i potenziali attrattivi (Attractive); secondo, controllare se il robot si trova a meno di un'unità di distanza dal goal ed eventualmente assegnare come stato quello paraboloide. La classe Paraboloidal si limiterà ad eseguire il metodo decision così come é stato ridefinito in Attractive.
\begin{lstlisting}
function obj = decision(obj,robot,dObstacle)
	decision@Attractive(obj,robot,dObstacle);
	rx = robot.xc; ry = robot.yc; grid = robot.grid;
	if norm([rx,ry]-grid.goal) < 1
		newattractive = Paraboloidal(grid);
		robot.attractive = newattractive;
		robot.setState(newattractive);
	end
end
\end{lstlisting}

\subsection{Switching allo stato bypassante}
Il costruttore di VirtualBypassing (si spiegherà successivamente perché il prefisso Virtual), fulcro di tutto il progetto, ha la responsabilità di calcolare il potenziale bypassante e tutto ciò di necessario affinché il robot sia in grado di giungere in una posa in cui non collida con l'ostacolo; nel linguaggio dello statechart costituisce la entry action del macrostato "Potenziale Bypassante" in figura \ref{state}. L'obiettivo ultimo del metodo, perció, é di scambiare il potenziale correntemente in uso con quello bypassante. Naturalmente, il bypassing viene fatto con una ratio che si basa sulla velocità e la direzione di movimento dell'ostacolo da aggirare; in particolare, gli aspetti cardine da considerare sono:
\begin{itemize}
\item La scelta del verso di bypassing
\item Nessuna discontinuità nella traiettoria dovuta allo switch tra i potenziali
\end{itemize}

\paragraph{Primo aspetto}
La scelta del verso di bypassing é cruciale per una buona riuscita senza collisioni. Le possibilità, naturalmente, sono due: orario e antiorario.
\begin{lstlisting}
function sense = chooseSense(~,obstacle,pose)
	xr = pose(1); yr = pose(2); thetar = pose(3);
	phi = atan2(obstacle.yc - yr,obstacle.xc - xr);
	alphav = atan2(obstacle.v(2),obstacle.v(1));
	vphi = pi/2 - phi + alphav
	vphi = atan2(sin(vphi),cos(vphi));
	if cos(vphi) > 0
		sense = "clock";
	else
		sense = "counterclock";
	end
end
\end{lstlisting} 
Nel listing é riportato il metodo chooseSense - si trova nella classe VirtualBypassing - che riceve in input un ostacolo e la posa del robot e restituisce in output una stringa indicante il verso di percorrenza di quell'ostacolo. Si estrae in phi l'angolo tra robot e ostacolo rispetto all'orizzontale e in alphav l'angolo corrispondente alla direzione con cui viaggia al momento l'ostacolo. Successivamente, tramite l'angolo vphi si controlla se il vettore velocità dell'ostacolo punta verso il semipiano sinistro o destro del sistema di riferimento fittizio in figura: nel primo caso il verso di percorrenza sarà quello antiorario, orario nel secondo caso.\\
Aggiungere figura su scelta verso 

\paragraph{Secondo aspetto}
Lo scopo é quello di generare una traiettoria "smooth", che sia in grado di assicurare continuità al moto del robot. Ci si pone quindi il problema di calcolare, nel momento in cui un ostacolo é stato rilevato, la velocitá e direzione di movimento del robot dopo lo switch. Nella pratica questo problema consiste, in prima battuta, nel calcolare il \textbf{punto preciso} in cui eseguire lo switch e il \textbf{coefficiente moltiplicativo} \(c\) - compare nell'antigradiente del potenziale bypassante in formula \ref{antigradB} - che modula la velocità di bypassing. Tuttavia, un'ulteriore problematica é data dalla possibilità che il potenziale di bypass possa \textbf{riaggiornarsi}, conseguentemente al fatto che l'ostacolo potrebbe essere ripetutamente ri-rilevato (dopo la prima volta); in quest'ottica l'ostacolo verrà comunque bypassato, ma il movimento del robot potrebbe essere soggetto a discontinuità involute o, in generale, comportamenti non del tutto predicibili a priori. \\
L'idea di fondo dietro la \textbf{soluzione} é di calcolare il potenziale bypassante nell'istante \(\tau\) in cui viene rilevato per la prima l'ostacolo e mantenerlo fisso per tutta la durata del bypass. Quindi \[-\nabla U_b \left( r(t) , O_j(t) \right) \Rightarrow -\nabla U_b \left( r(t) , O_j(\tau) \right) \]
\begin{nota}
\textbf{Nota} \\ Considerando questa strategia, potrebbe sorgere un problema nel caso in cui un ostacolo cambi direzione durante il bypass. Tuttavia, si é deciso, per scopi esemplificativi, di tralasciare questo aspetto, anche perché può essere gestito indipendentemente dalla struttura portante del modulo di pianificazione, con l'aiuto del modulo di visione.
\end{nota}
Una volta rilevato l'ostacolo nell'istante \(\tau\), il compito del pianificatore é di assegnare al robot un nuovo potenziale da seguire; questo, al fine di rendere continuo lo switch, sarà posizionato in un ostacolo virtuale e non, come ci si potrebbe aspettare, in quello realmente rilevato. La motivazione dietro a questo procedimento é la seguente. Le linee di campo del potenziale bypassante sono delle circonferenze. Il robot possiede in ogni istante una velocità, data da un vettore bidimensionale. Quindi, per far "rientrare" il robot sul potenziale bypassante in maniera continua, bisogna trovare quella circonferenza che tange la traiettoria del robot nell'istante \(\tau\). La circonferenza cercata, in pratica, sarà una linea di campo del potenziale bypassante centrato nell'ostacolo virtuale. Solo successivamente il robot seguirà effettivamente il potenziale centrato nell'ostacolo reale. 

Figura circonferenze\\

Più in dettaglio, gli "ingredienti" del potenziale bypassante sono:
\begin{enumerate}
\item Posizione dell'ostacolo virtuale
\item Punto in cui switchare dall'ostacolo virtuale al reale
\item Coefficiente dell'antigradiente nell'ostacolo virtuale e reale
\end{enumerate}
Il primo punto si configura come un sistema di due equazioni in due incognite, ovvero \([x_{\Omega}, y_{\Omega}]\). Uno dei due vincoli é dato dalla condizione di tangenza tra la circonferenza centrata in  \([x_{\Omega}, y_{\Omega}]\) e la direzione di moto del robot in \(\tau\). A tal fine si può supporre, senza perdita di generalità, che il robot si trovi nell'origine all'istante \(\tau\). Da ciò ne deriva che l'equazione della circonferenza centrata in \([x_{\Omega}, y_{\Omega}]\) diventa \[d^2=x_{\Omega}^2+y_{\Omega}^2\] dove \(d\) é il raggio della circonferenza. La condizione di tangenza é soddisfatta se \[x_{\Omega} = -m\cdot  y_{\Omega}\] dove \(m = \tan(\theta_r)\), cioè la direzione di moto del robot. In pratica, questa equazione afferma che la retta, che congiunge il robot al punto \([x_{\Omega}, y_{\Omega}]\), deve essere perpendicolare a \(\tan(\theta_r)\). L'altro vincolo si ricollega al secondo punto della "lista di ingredienti": bisogna imporre (con un ragionamento simile al primo vincolo) che la circonferenza "omega" sia tangente alla circonferenza attorno all'ostacolo reale nel punto di switch tra i due potenziali bypassanti. Di conseguenza si impone che \[(x_{\Omega} - x_o)^2 + (y_{\Omega} - y_o)^2 = (d+h)^2\] dove \([x_o, y_o]\) é il centro della circonferenza nell'ostacolo e \(h\) il suo raggio. Riunendo i due vincoli in un sistema si ottengono le due equazioni in due incognite
\begin{equation}
\begin{cases}
x_{\Omega} = -m\cdot  y_{\Omega} \\
(x_{\Omega} - x_o)^2 + (y_{\Omega} - y_o)^2 = (\sqrt{x_{\Omega}^2+y_{\Omega}^2}+h)^2
\end{cases}
\end{equation}
Risolvendo questo sistema per \(y_{\Omega}\) si ottengono due possibili soluzioni
\begin{equation}
\begin{cases}
y_{\Omega,1}=\frac{(-h^2 + x_o^2 + y_o^2)(m x_o - y_o + h\sqrt{m^2+1})}{2h^2m^2 + 2h^2 - 2m^2x_o^2 + 4mx_oy_o - 2y_o^2} \\\\
y_{\Omega,2}=\frac{-(-h^2 + x_o^2 + y_o^2)(m x_o - y_o + h\sqrt{m^2+1})}{2h^2m^2 + 2h^2 - 2m^2x_o^2 + 4mx_oy_o - 2y_o^2}
\end{cases}
\end{equation}
\(x_{\Omega}\) viene poi trovato per sostituzione. La scelta di una soluzione piuttosto che l'altra - in linea di massima, una sarà a sinistra dell'asse tra robot e ostacolo e l'altra sulla destra - dipenderà dal verso di bypassing (verrà affrontato successivamente, così come anche il calcolo di P1).\\
Una volta calcolata la posizione dell'ostacolo virtuale e del punto di switch tra ostacolo virtuale e reale, é necessario calcolare il punto P2 di switch tra il potenziale bypassante e quello attrattivo. L'idea per risolvere tale problema é di trovare, tra le infinitamente possibili, una retta che passi per il punto di goal e tanga la circonferenza centrata nell'ostacolo reale proprio in P2. Anche in questo caso le soluzioni possibili saranno due; quella idonea verrà scelta in base al verso di bypassing. Innanzitutto, il fascio di rette che partono dal punto di goal e passano dal punto cercato sono esprimibili come \[y-y_g = m(x-x_g)\] dove \(x\) e \(y\) sono le coordinate del punto P2 cercato. Inoltre, il punto P2 si troverà naturalmente sulla circonferenza centrata nell'ostacolo reale \[(x-x_o)^2+(y-y_o)^2=h^2\] e sostituendo in questa l'espressione della retta in funzione di \(y\), si ottiene un'equazione che esprime i possibili punti di intersezione tra la generica retta e la circonferenza	
\[(m^2+1)x^2 -2(x_o+m(y_o-y_g+mx_g)x + (y_o-y_g+mx_g)^2+x_o^2-h^2=0\]
Ovviamente ci sono troppe incognite per poter risolvere questa equazione, ma noi interessa la coppia di rette tale per cui esse sono tangenti alla circonferenza. Ciò equivale a imporre che il punto di intersezione sia uno solo e quindi che quest'equazione di secondo grado abbia una sola soluzione. La conseguenza é che troviamo i due coefficienti angolari ponendo a zero il delta dell'equazione\[(-2x_o - 2m(y_o+y_g+mx_g))^2 - 4(m+1)((y_o-y_g+mx_g)^2+x_o^2-h^2)=0\] e le due soluzioni saranno 
\[\begin{cases} 
m_1=\frac{(x_g-x_o)(y_o-y_g)+h\sqrt{-h^2+(x_g-x_o)^2+(y_g-y_o)^2}}{h^2-(x_g-x_o)^2} \\\\
m_2=-\frac{(x_g-x_o)(y_o-y_g)+h\sqrt{-h^2+(x_g-x_o)^2+(y_g-y_o)^2}}{h^2-(x_g-x_o)^2} 
\end{cases}\]
grazie alle quali é possibile trovare le due soluzioni per P2.\\
Detto questo, si può riassumere tutto il procedimento di switching ripercorrendo il costruttore di VirtualBypassing.
\begin{enumerate}
\item 
\end{enumerate}
	
\subsection{Stato bypassante}
%Caso Bypassante
	%Controllo ostacolo diverso
	%Controllo P1
	%Controllo P2

\section{Modulo di percezione}
%Come vengono percepiti gli ostacoli e le loro velocità
%Come viene percepita la propria posizione (localizzazione)


\section{Risultati}
%Parametri utilizzati
%Un ostacolo fermo e in movimento
%Minimi locali e confronto con potenziali artificiali classici
%Tre in movimento

\section{Applicazioni e sviluppi futuri}
%Rimozione di alcune ipotesi semplificative
%Situazioni di stallo
%Ostacoli di forma diversa

\newpage
%%Modulo responsabile per il robot
%\begin{adjustbox}{width=\textwidth , bgcolor=backcolour}
%\lstinputlisting[caption=Classe per il Robot, label={robot1},language=Matlab, lastline=80]{"../OOP/Robot.m"}
%\end{adjustbox}

\newpage \lstlistoflistings 
\listoffigures
\newpage\printbibliography

\end{document}
