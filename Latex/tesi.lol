\contentsline {lstlisting}{\numberline {3.1}{\ignorespaces Entry point del modulo software}}{19}{}%
\contentsline {lstlisting}{\numberline {4.1}{\ignorespaces Metodo che converte coordinate cartesiane in indici della meshgrid}}{20}{}%
\contentsline {lstlisting}{\numberline {5.1}{\ignorespaces Metodo che esprime lo specifico modello cinematico}}{23}{}%
\contentsline {lstlisting}{\numberline {5.2}{\ignorespaces Metodo che genera i comandi di velocit√†}}{23}{}%
\contentsline {lstlisting}{\numberline {6.1}{\ignorespaces Classe asratta RobotState}}{26}{}%
\contentsline {lstlisting}{\numberline {6.2}{\ignorespaces Campi della classe SwitchingRobot}}{26}{}%
\contentsline {lstlisting}{\numberline {6.3}{\ignorespaces Classe astratta Attractive (erede di RobotState)}}{26}{}%
\contentsline {lstlisting}{\numberline {6.4}{\ignorespaces Costruttore di SwitchingRobot}}{27}{}%
\contentsline {lstlisting}{\numberline {6.5}{\ignorespaces Costruttore di Conical}}{27}{}%
\contentsline {lstlisting}{\numberline {6.6}{\ignorespaces Ridefinizione del metodo decision in Conical}}{27}{}%
\contentsline {lstlisting}{\numberline {6.7}{\ignorespaces Calcolo del verso di bypassing (orario o antiorario)}}{28}{}%
\contentsline {lstlisting}{\numberline {6.8}{\ignorespaces Istruzioni per calcolare h}}{34}{}%
\contentsline {lstlisting}{\numberline {6.9}{\ignorespaces Istruzioni per calcolare \(x_{\Omega }\) e \(y_{\Omega }\)}}{35}{}%
\contentsline {lstlisting}{\numberline {6.10}{\ignorespaces Istruzioni per scegliere la circonferenza idonea}}{35}{}%
\contentsline {lstlisting}{\numberline {6.11}{\ignorespaces Istruzioni per calcolare P1}}{36}{}%
\contentsline {lstlisting}{\numberline {6.12}{\ignorespaces Istruzioni per calcolare P2}}{36}{}%
\contentsline {lstlisting}{\numberline {6.13}{\ignorespaces Istruzioni per calcolare il potenziale bypassante reale}}{36}{}%
\contentsline {lstlisting}{\numberline {6.14}{\ignorespaces Istruzioni per calcolare il potenziale bypassante virtuale}}{36}{}%
\contentsline {lstlisting}{\numberline {6.15}{\ignorespaces Classe astratta Bypassing (erede di RobotState)}}{38}{}%
\contentsline {lstlisting}{\numberline {6.16}{\ignorespaces Ridefinizione del metodo decision di VirtualBypassing}}{39}{}%
\contentsline {lstlisting}{\numberline {6.17}{\ignorespaces Ridefinizione del metodo decision di RealBypassing}}{39}{}%
\contentsline {lstlisting}{\numberline {7.1}{\ignorespaces Classe per il modulo di percezione}}{40}{}%
\contentsline {lstlisting}{\numberline {8.1}{\ignorespaces Entry point del modulo software}}{42}{}%
\contentsline {lstlisting}{\numberline {8.2}{\ignorespaces Metodo responsabile di far muovere il robot in simulazione}}{42}{}%
\contentsline {lstlisting}{\numberline {8.3}{\ignorespaces Istruzioni per avviare la simulazione}}{43}{}%
